"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/store/slices/authSlice.js":
/*!***************************************!*\
  !*** ./src/store/slices/authSlice.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearCredentials: () => (/* binding */ clearCredentials),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   logout: () => (/* binding */ logout),\n/* harmony export */   refreshAccessToken: () => (/* binding */ refreshAccessToken),\n/* harmony export */   register: () => (/* binding */ register),\n/* harmony export */   resetAuthState: () => (/* binding */ resetAuthState),\n/* harmony export */   selectAuthError: () => (/* binding */ selectAuthError),\n/* harmony export */   selectAuthLoading: () => (/* binding */ selectAuthLoading),\n/* harmony export */   selectAuthToken: () => (/* binding */ selectAuthToken),\n/* harmony export */   selectCurrentUser: () => (/* binding */ selectCurrentUser),\n/* harmony export */   selectIsAuthenticated: () => (/* binding */ selectIsAuthenticated),\n/* harmony export */   setCredentials: () => (/* binding */ setCredentials),\n/* harmony export */   verifyMFA: () => (/* binding */ verifyMFA)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _services_authService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../services/authService */ \"(pages-dir-browser)/./src/services/authService.js\");\n/* harmony import */ var _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils/secureStorage */ \"(pages-dir-browser)/./src/lib/utils/secureStorage.js\");\n/* harmony import */ var _config_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config/constants */ \"(pages-dir-browser)/./src/config/constants.js\");\n\n\n\n\n// Define initial state\nconst initialState = {\n    user: null,\n    token: null,\n    refreshToken: null,\n    isAuthenticated: false,\n    isLoading: false,\n    error: null,\n    mfaRequired: false,\n    mfaToken: null\n};\n// Async thunks\nconst login = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)('auth/login', async (credentials, param)=>{\n    let { rejectWithValue } = param;\n    try {\n        const response = await _services_authService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].login(credentials);\n        // Check if MFA is required\n        if (response.requireMFA) {\n            // For MFA flow, we don't store the tokens yet\n            // We just return the response with the MFA token\n            // Add partial login to history\n            _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.addLoginToHistory({\n                id: Date.now().toString(),\n                device: navigator.userAgent,\n                location: 'Unknown',\n                status: 'pending_mfa'\n            });\n            return {\n                requireMFA: true,\n                mfaToken: response.mfaToken,\n                email: credentials.email,\n                rememberMe: credentials.rememberMe\n            };\n        }\n        // No MFA required, proceed with normal login flow\n        // Store tokens and user data in secure storage\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setAuthTokens({\n            token: response.token,\n            refreshToken: response.refreshToken\n        }, credentials.rememberMe);\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setUserData(response.user, credentials.rememberMe);\n        // Add login to history\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.addLoginToHistory({\n            id: Date.now().toString(),\n            device: navigator.userAgent,\n            location: 'Unknown',\n            status: 'success'\n        });\n        return response;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        // Add failed login to history\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.addLoginToHistory({\n            id: Date.now().toString(),\n            device: navigator.userAgent,\n            location: 'Unknown',\n            status: 'failed'\n        });\n        return rejectWithValue(((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Login failed');\n    }\n});\nconst register = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)('auth/register', async (userData, param)=>{\n    let { rejectWithValue } = param;\n    try {\n        const response = await _services_authService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].register(userData);\n        // Store tokens and user data in secure storage\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setAuthTokens({\n            token: response.token,\n            refreshToken: response.refreshToken\n        }, true); // Always remember new registrations\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setUserData(response.user, true);\n        // Add login to history\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.addLoginToHistory({\n            id: Date.now().toString(),\n            device: navigator.userAgent,\n            location: 'Unknown',\n            status: 'success'\n        });\n        return response;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        return rejectWithValue(((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Registration failed');\n    }\n});\nconst logout = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)('auth/logout', async (_, param)=>{\n    let { rejectWithValue } = param;\n    try {\n        // Get tokens before clearing storage\n        const tokens = _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getAuthTokens();\n        // Clear secure storage first\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.clearAuthStorage();\n        // Only call API if we have a token\n        if (tokens === null || tokens === void 0 ? void 0 : tokens.token) {\n            try {\n                await _services_authService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logout();\n            } catch (logoutError) {\n                // Even if the server-side logout fails, we still want to clear the client-side state\n                console.error('Server logout failed, but client logout succeeded', logoutError);\n            }\n        }\n        // Clear any cached API responses\n        if (true) {\n            // Clear any application cache\n            const cacheKeys = Object.keys(localStorage).filter((key)=>key.startsWith('cache-'));\n            cacheKeys.forEach((key)=>localStorage.removeItem(key));\n            // Clear any service worker caches if needed\n            if ('caches' in window) {\n                try {\n                    caches.keys().then((names)=>{\n                        names.forEach((name)=>{\n                            caches.delete(name);\n                        });\n                    });\n                } catch (e) {\n                    console.error('Error clearing caches:', e);\n                }\n            }\n        }\n        return null;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        // Even if there's an error, we still want to clear the client-side state\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.clearAuthStorage();\n        return rejectWithValue(((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Logout failed');\n    }\n});\nconst verifyMFA = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)('auth/verifyMFA', async (param, param1)=>{\n    let { mfaToken, code, email, rememberMe, isBackupCode = false } = param, { rejectWithValue } = param1;\n    try {\n        // Call the API to verify the MFA code\n        const response = await _services_authService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].verifyMFALogin({\n            mfaToken,\n            code,\n            isBackupCode\n        });\n        // If verification is successful, store tokens and user data\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setAuthTokens({\n            token: response.token,\n            refreshToken: response.refreshToken\n        }, rememberMe);\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setUserData(response.user, rememberMe);\n        // Update login history\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.addLoginToHistory({\n            id: Date.now().toString(),\n            device: navigator.userAgent,\n            location: 'Unknown',\n            status: 'success_mfa'\n        });\n        return response;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        // Add failed MFA verification to history\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.addLoginToHistory({\n            id: Date.now().toString(),\n            device: navigator.userAgent,\n            location: 'Unknown',\n            status: 'failed_mfa'\n        });\n        return rejectWithValue(((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'MFA verification failed');\n    }\n});\nconst refreshAccessToken = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)('auth/refreshToken', async (_, param)=>{\n    let { rejectWithValue } = param;\n    try {\n        // Get refresh token from secure storage\n        const tokens = _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getAuthTokens();\n        if (!(tokens === null || tokens === void 0 ? void 0 : tokens.refreshToken)) {\n            return rejectWithValue('No refresh token available');\n        }\n        const response = await _services_authService__WEBPACK_IMPORTED_MODULE_0__[\"default\"].refreshToken(tokens.refreshToken);\n        // Update tokens in secure storage\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.setAuthTokens({\n            token: response.token,\n            refreshToken: response.refreshToken\n        });\n        return response;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        // If refresh fails, clear auth storage\n        _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.clearAuthStorage();\n        return rejectWithValue(((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Token refresh failed');\n    }\n});\n// Helper function to initialize state from secure storage\nconst initializeAuthState = ()=>{\n    // Check if we're in a browser environment\n    if (true) {\n        try {\n            const tokens = _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getAuthTokens();\n            const userData = _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getUserData();\n            if (tokens && userData) {\n                return {\n                    ...initialState,\n                    user: userData,\n                    token: tokens.token,\n                    refreshToken: tokens.refreshToken,\n                    isAuthenticated: true\n                };\n            }\n        } catch (error) {\n            console.error('Error initializing auth state from secure storage:', error);\n            // If there's an error, clear storage and start fresh\n            _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.clearAuthStorage();\n        }\n    }\n    return initialState;\n};\n// Create slice\nconst authSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createSlice)({\n    name: 'auth',\n    initialState: initializeAuthState(),\n    reducers: {\n        resetAuthState: (state)=>{\n            state.isLoading = false;\n            state.error = null;\n        },\n        setCredentials: (state, action)=>{\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n            state.refreshToken = action.payload.refreshToken;\n            state.isAuthenticated = true;\n            state.mfaRequired = false;\n            state.mfaToken = null;\n        },\n        clearCredentials: (state)=>{\n            state.user = null;\n            state.token = null;\n            state.refreshToken = null;\n            state.isAuthenticated = false;\n            state.mfaRequired = false;\n            state.mfaToken = null;\n        },\n        cancelMFA: (state)=>{\n            state.mfaRequired = false;\n            state.mfaToken = null;\n            state.error = null;\n        }\n    },\n    extraReducers: (builder)=>{\n        builder// Login\n        .addCase(login.pending, (state)=>{\n            state.isLoading = true;\n            state.error = null;\n        }).addCase(login.fulfilled, (state, action)=>{\n            state.isLoading = false;\n            state.isAuthenticated = true;\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n            state.refreshToken = action.payload.refreshToken;\n        }).addCase(login.rejected, (state, action)=>{\n            state.isLoading = false;\n            state.error = action.payload;\n        })// Register\n        .addCase(register.pending, (state)=>{\n            state.isLoading = true;\n            state.error = null;\n        }).addCase(register.fulfilled, (state, action)=>{\n            state.isLoading = false;\n            state.isAuthenticated = true;\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n            state.refreshToken = action.payload.refreshToken;\n        }).addCase(register.rejected, (state, action)=>{\n            state.isLoading = false;\n            state.error = action.payload;\n        })// Logout\n        .addCase(logout.pending, (state)=>{\n            state.isLoading = true;\n        }).addCase(logout.fulfilled, (state)=>{\n            state.isLoading = false;\n            state.isAuthenticated = false;\n            state.user = null;\n            state.token = null;\n            state.refreshToken = null;\n        }).addCase(logout.rejected, (state, action)=>{\n            state.isLoading = false;\n            state.error = action.payload;\n        })// Refresh token\n        .addCase(refreshAccessToken.pending, (state)=>{\n            state.isLoading = true;\n        }).addCase(refreshAccessToken.fulfilled, (state, action)=>{\n            state.isLoading = false;\n            state.token = action.payload.token;\n            state.refreshToken = action.payload.refreshToken;\n        }).addCase(refreshAccessToken.rejected, (state, action)=>{\n            state.isLoading = false;\n            state.error = action.payload;\n            state.isAuthenticated = false;\n            state.user = null;\n            state.token = null;\n            state.refreshToken = null;\n        });\n    }\n});\n// Export actions\nconst { resetAuthState, setCredentials, clearCredentials } = authSlice.actions;\n// Export selectors\nconst selectCurrentUser = (state)=>{\n    // First try to get from state\n    if (state.auth.user) {\n        return state.auth.user;\n    }\n    // If not in state, try to get from secure storage\n    if (true) {\n        return _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getUserData();\n    }\n    return null;\n};\nconst selectIsAuthenticated = (state)=>{\n    // First check state\n    if (state.auth.isAuthenticated) {\n        return true;\n    }\n    // If not authenticated in state, check secure storage\n    if (true) {\n        return !!_lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getAuthTokens();\n    }\n    return false;\n};\nconst selectAuthToken = (state)=>{\n    // First try to get from state\n    if (state.auth.token) {\n        return state.auth.token;\n    }\n    // If not in state, try to get from secure storage\n    if (true) {\n        const tokens = _lib_utils_secureStorage__WEBPACK_IMPORTED_MODULE_1__.secureStorage.getAuthTokens();\n        return (tokens === null || tokens === void 0 ? void 0 : tokens.token) || null;\n    }\n    return null;\n};\nconst selectAuthError = (state)=>state.auth.error;\nconst selectAuthLoading = (state)=>state.auth.isLoading;\n// Export reducer\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (authSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9zdG9yZS9zbGljZXMvYXV0aFNsaWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNaO0FBQ1M7QUFDZDtBQUVoRCx1QkFBdUI7QUFDdkIsTUFBTUssZUFBZTtJQUNuQkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLGNBQWM7SUFDZEMsaUJBQWlCO0lBQ2pCQyxXQUFXO0lBQ1hDLE9BQU87SUFDUEMsYUFBYTtJQUNiQyxVQUFVO0FBQ1o7QUFFQSxlQUFlO0FBQ1IsTUFBTUMsUUFBUWIsa0VBQWdCQSxDQUNuQyxjQUNBLE9BQU9jO1FBQWEsRUFBRUMsZUFBZSxFQUFFO0lBQ3JDLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1mLG1FQUFpQixDQUFDYTtRQUV6QywyQkFBMkI7UUFDM0IsSUFBSUUsU0FBU0MsVUFBVSxFQUFFO1lBQ3ZCLDhDQUE4QztZQUM5QyxpREFBaUQ7WUFDakQsK0JBQStCO1lBQy9CZixtRUFBYUEsQ0FBQ2dCLGlCQUFpQixDQUFDO2dCQUM5QkMsSUFBSUMsS0FBS0MsR0FBRyxHQUFHQyxRQUFRO2dCQUN2QkMsUUFBUUMsVUFBVUMsU0FBUztnQkFDM0JDLFVBQVU7Z0JBQ1ZDLFFBQVE7WUFDVjtZQUVBLE9BQU87Z0JBQ0xWLFlBQVk7Z0JBQ1pMLFVBQVVJLFNBQVNKLFFBQVE7Z0JBQzNCZ0IsT0FBT2QsWUFBWWMsS0FBSztnQkFDeEJDLFlBQVlmLFlBQVllLFVBQVU7WUFDcEM7UUFDRjtRQUVBLGtEQUFrRDtRQUNsRCwrQ0FBK0M7UUFDL0MzQixtRUFBYUEsQ0FBQzRCLGFBQWEsQ0FBQztZQUMxQnhCLE9BQU9VLFNBQVNWLEtBQUs7WUFDckJDLGNBQWNTLFNBQVNULFlBQVk7UUFDckMsR0FBR08sWUFBWWUsVUFBVTtRQUV6QjNCLG1FQUFhQSxDQUFDNkIsV0FBVyxDQUFDZixTQUFTWCxJQUFJLEVBQUVTLFlBQVllLFVBQVU7UUFFL0QsdUJBQXVCO1FBQ3ZCM0IsbUVB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c0IsT0FBTyxFQUFDIiwic291cmNlcyI6WyJEOlxcUFJPSkVDVFxcc2FyYW5hLWFwcFxcYXBwc1xcd2ViXFxzcmNcXHN0b3JlXFxzbGljZXNcXGF1dGhTbGljZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IGF1dGhTZXJ2aWNlIGZyb20gJy4uLy4uL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcbmltcG9ydCB7IHNlY3VyZVN0b3JhZ2UgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMvc2VjdXJlU3RvcmFnZSc7XG5pbXBvcnQgeyBST1VURVMgfSBmcm9tICcuLi8uLi9jb25maWcvY29uc3RhbnRzJztcblxuLy8gRGVmaW5lIGluaXRpYWwgc3RhdGVcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgdXNlcjogbnVsbCxcbiAgdG9rZW46IG51bGwsXG4gIHJlZnJlc2hUb2tlbjogbnVsbCxcbiAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgZXJyb3I6IG51bGwsXG4gIG1mYVJlcXVpcmVkOiBmYWxzZSxcbiAgbWZhVG9rZW46IG51bGwsXG59O1xuXG4vLyBBc3luYyB0aHVua3NcbmV4cG9ydCBjb25zdCBsb2dpbiA9IGNyZWF0ZUFzeW5jVGh1bmsoXG4gICdhdXRoL2xvZ2luJyxcbiAgYXN5bmMgKGNyZWRlbnRpYWxzLCB7IHJlamVjdFdpdGhWYWx1ZSB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aFNlcnZpY2UubG9naW4oY3JlZGVudGlhbHMpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBNRkEgaXMgcmVxdWlyZWRcbiAgICAgIGlmIChyZXNwb25zZS5yZXF1aXJlTUZBKSB7XG4gICAgICAgIC8vIEZvciBNRkEgZmxvdywgd2UgZG9uJ3Qgc3RvcmUgdGhlIHRva2VucyB5ZXRcbiAgICAgICAgLy8gV2UganVzdCByZXR1cm4gdGhlIHJlc3BvbnNlIHdpdGggdGhlIE1GQSB0b2tlblxuICAgICAgICAvLyBBZGQgcGFydGlhbCBsb2dpbiB0byBoaXN0b3J5XG4gICAgICAgIHNlY3VyZVN0b3JhZ2UuYWRkTG9naW5Ub0hpc3Rvcnkoe1xuICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgZGV2aWNlOiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgIGxvY2F0aW9uOiAnVW5rbm93bicsIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgZGV0ZXJtaW5lZCBieSBnZW9sb2NhdGlvbiBvciBJUFxuICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmdfbWZhJyxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlcXVpcmVNRkE6IHRydWUsXG4gICAgICAgICAgbWZhVG9rZW46IHJlc3BvbnNlLm1mYVRva2VuLFxuICAgICAgICAgIGVtYWlsOiBjcmVkZW50aWFscy5lbWFpbCxcbiAgICAgICAgICByZW1lbWJlck1lOiBjcmVkZW50aWFscy5yZW1lbWJlck1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE5vIE1GQSByZXF1aXJlZCwgcHJvY2VlZCB3aXRoIG5vcm1hbCBsb2dpbiBmbG93XG4gICAgICAvLyBTdG9yZSB0b2tlbnMgYW5kIHVzZXIgZGF0YSBpbiBzZWN1cmUgc3RvcmFnZVxuICAgICAgc2VjdXJlU3RvcmFnZS5zZXRBdXRoVG9rZW5zKHtcbiAgICAgICAgdG9rZW46IHJlc3BvbnNlLnRva2VuLFxuICAgICAgICByZWZyZXNoVG9rZW46IHJlc3BvbnNlLnJlZnJlc2hUb2tlblxuICAgICAgfSwgY3JlZGVudGlhbHMucmVtZW1iZXJNZSk7XG4gICAgICBcbiAgICAgIHNlY3VyZVN0b3JhZ2Uuc2V0VXNlckRhdGEocmVzcG9uc2UudXNlciwgY3JlZGVudGlhbHMucmVtZW1iZXJNZSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBsb2dpbiB0byBoaXN0b3J5XG4gICAgICBzZWN1cmVTdG9yYWdlLmFkZExvZ2luVG9IaXN0b3J5KHtcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgZGV2aWNlOiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICBsb2NhdGlvbjogJ1Vua25vd24nLCAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGRldGVybWluZWQgYnkgZ2VvbG9jYXRpb24gb3IgSVBcbiAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBBZGQgZmFpbGVkIGxvZ2luIHRvIGhpc3RvcnlcbiAgICAgIHNlY3VyZVN0b3JhZ2UuYWRkTG9naW5Ub0hpc3Rvcnkoe1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBkZXZpY2U6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgIGxvY2F0aW9uOiAnVW5rbm93bicsXG4gICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlamVjdFdpdGhWYWx1ZShlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnTG9naW4gZmFpbGVkJyk7XG4gICAgfVxuICB9XG4pO1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXIgPSBjcmVhdGVBc3luY1RodW5rKFxuICAnYXV0aC9yZWdpc3RlcicsXG4gIGFzeW5jICh1c2VyRGF0YSwgeyByZWplY3RXaXRoVmFsdWUgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhTZXJ2aWNlLnJlZ2lzdGVyKHVzZXJEYXRhKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdG9rZW5zIGFuZCB1c2VyIGRhdGEgaW4gc2VjdXJlIHN0b3JhZ2VcbiAgICAgIHNlY3VyZVN0b3JhZ2Uuc2V0QXV0aFRva2Vucyh7XG4gICAgICAgIHRva2VuOiByZXNwb25zZS50b2tlbixcbiAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZS5yZWZyZXNoVG9rZW5cbiAgICAgIH0sIHRydWUpOyAvLyBBbHdheXMgcmVtZW1iZXIgbmV3IHJlZ2lzdHJhdGlvbnNcbiAgICAgIFxuICAgICAgc2VjdXJlU3RvcmFnZS5zZXRVc2VyRGF0YShyZXNwb25zZS51c2VyLCB0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGxvZ2luIHRvIGhpc3RvcnlcbiAgICAgIHNlY3VyZVN0b3JhZ2UuYWRkTG9naW5Ub0hpc3Rvcnkoe1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBkZXZpY2U6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgIGxvY2F0aW9uOiAnVW5rbm93bicsIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgZGV0ZXJtaW5lZCBieSBnZW9sb2NhdGlvbiBvciBJUFxuICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUoZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ1JlZ2lzdHJhdGlvbiBmYWlsZWQnKTtcbiAgICB9XG4gIH1cbik7XG5cbmV4cG9ydCBjb25zdCBsb2dvdXQgPSBjcmVhdGVBc3luY1RodW5rKFxuICAnYXV0aC9sb2dvdXQnLFxuICBhc3luYyAoXywgeyByZWplY3RXaXRoVmFsdWUgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdG9rZW5zIGJlZm9yZSBjbGVhcmluZyBzdG9yYWdlXG4gICAgICBjb25zdCB0b2tlbnMgPSBzZWN1cmVTdG9yYWdlLmdldEF1dGhUb2tlbnMoKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgc2VjdXJlIHN0b3JhZ2UgZmlyc3RcbiAgICAgIHNlY3VyZVN0b3JhZ2UuY2xlYXJBdXRoU3RvcmFnZSgpO1xuICAgICAgXG4gICAgICAvLyBPbmx5IGNhbGwgQVBJIGlmIHdlIGhhdmUgYSB0b2tlblxuICAgICAgaWYgKHRva2Vucz8udG9rZW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBhdXRoU2VydmljZS5sb2dvdXQoKTtcbiAgICAgICAgfSBjYXRjaCAobG9nb3V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZXJ2ZXItc2lkZSBsb2dvdXQgZmFpbHMsIHdlIHN0aWxsIHdhbnQgdG8gY2xlYXIgdGhlIGNsaWVudC1zaWRlIHN0YXRlXG4gICAgICAgICAgY29uc29sZS5lcnJvcignU2VydmVyIGxvZ291dCBmYWlsZWQsIGJ1dCBjbGllbnQgbG9nb3V0IHN1Y2NlZWRlZCcsIGxvZ291dEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDbGVhciBhbnkgY2FjaGVkIEFQSSByZXNwb25zZXNcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBDbGVhciBhbnkgYXBwbGljYXRpb24gY2FjaGVcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdjYWNoZS0nKSk7XG4gICAgICAgIGNhY2hlS2V5cy5mb3JFYWNoKGtleSA9PiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGFueSBzZXJ2aWNlIHdvcmtlciBjYWNoZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmICgnY2FjaGVzJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FjaGVzLmtleXMoKS50aGVuKG5hbWVzID0+IHtcbiAgICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICBjYWNoZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGNhY2hlczonLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEV2ZW4gaWYgdGhlcmUncyBhbiBlcnJvciwgd2Ugc3RpbGwgd2FudCB0byBjbGVhciB0aGUgY2xpZW50LXNpZGUgc3RhdGVcbiAgICAgIHNlY3VyZVN0b3JhZ2UuY2xlYXJBdXRoU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIHJlamVjdFdpdGhWYWx1ZShlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnTG9nb3V0IGZhaWxlZCcpO1xuICAgIH1cbiAgfVxuKTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeU1GQSA9IGNyZWF0ZUFzeW5jVGh1bmsoXG4gICdhdXRoL3ZlcmlmeU1GQScsXG4gIGFzeW5jICh7IG1mYVRva2VuLCBjb2RlLCBlbWFpbCwgcmVtZW1iZXJNZSwgaXNCYWNrdXBDb2RlID0gZmFsc2UgfSwgeyByZWplY3RXaXRoVmFsdWUgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYWxsIHRoZSBBUEkgdG8gdmVyaWZ5IHRoZSBNRkEgY29kZVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoU2VydmljZS52ZXJpZnlNRkFMb2dpbih7XG4gICAgICAgIG1mYVRva2VuLFxuICAgICAgICBjb2RlLFxuICAgICAgICBpc0JhY2t1cENvZGVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJZiB2ZXJpZmljYXRpb24gaXMgc3VjY2Vzc2Z1bCwgc3RvcmUgdG9rZW5zIGFuZCB1c2VyIGRhdGFcbiAgICAgIHNlY3VyZVN0b3JhZ2Uuc2V0QXV0aFRva2Vucyh7XG4gICAgICAgIHRva2VuOiByZXNwb25zZS50b2tlbixcbiAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZS5yZWZyZXNoVG9rZW5cbiAgICAgIH0sIHJlbWVtYmVyTWUpO1xuICAgICAgXG4gICAgICBzZWN1cmVTdG9yYWdlLnNldFVzZXJEYXRhKHJlc3BvbnNlLnVzZXIsIHJlbWVtYmVyTWUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbG9naW4gaGlzdG9yeVxuICAgICAgc2VjdXJlU3RvcmFnZS5hZGRMb2dpblRvSGlzdG9yeSh7XG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIGRldmljZTogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgbG9jYXRpb246ICdVbmtub3duJyxcbiAgICAgICAgc3RhdHVzOiAnc3VjY2Vzc19tZmEnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gQWRkIGZhaWxlZCBNRkEgdmVyaWZpY2F0aW9uIHRvIGhpc3RvcnlcbiAgICAgIHNlY3VyZVN0b3JhZ2UuYWRkTG9naW5Ub0hpc3Rvcnkoe1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBkZXZpY2U6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgIGxvY2F0aW9uOiAnVW5rbm93bicsXG4gICAgICAgIHN0YXR1czogJ2ZhaWxlZF9tZmEnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUoZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ01GQSB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gICAgfVxuICB9XG4pO1xuXG5leHBvcnQgY29uc3QgcmVmcmVzaEFjY2Vzc1Rva2VuID0gY3JlYXRlQXN5bmNUaHVuayhcbiAgJ2F1dGgvcmVmcmVzaFRva2VuJyxcbiAgYXN5bmMgKF8sIHsgcmVqZWN0V2l0aFZhbHVlIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHJlZnJlc2ggdG9rZW4gZnJvbSBzZWN1cmUgc3RvcmFnZVxuICAgICAgY29uc3QgdG9rZW5zID0gc2VjdXJlU3RvcmFnZS5nZXRBdXRoVG9rZW5zKCk7XG4gICAgICBcbiAgICAgIGlmICghdG9rZW5zPy5yZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdFdpdGhWYWx1ZSgnTm8gcmVmcmVzaCB0b2tlbiBhdmFpbGFibGUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoU2VydmljZS5yZWZyZXNoVG9rZW4odG9rZW5zLnJlZnJlc2hUb2tlbik7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0b2tlbnMgaW4gc2VjdXJlIHN0b3JhZ2VcbiAgICAgIHNlY3VyZVN0b3JhZ2Uuc2V0QXV0aFRva2Vucyh7XG4gICAgICAgIHRva2VuOiByZXNwb25zZS50b2tlbixcbiAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZS5yZWZyZXNoVG9rZW5cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHJlZnJlc2ggZmFpbHMsIGNsZWFyIGF1dGggc3RvcmFnZVxuICAgICAgc2VjdXJlU3RvcmFnZS5jbGVhckF1dGhTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gcmVqZWN0V2l0aFZhbHVlKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdUb2tlbiByZWZyZXNoIGZhaWxlZCcpO1xuICAgIH1cbiAgfVxuKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgc3RhdGUgZnJvbSBzZWN1cmUgc3RvcmFnZVxuY29uc3QgaW5pdGlhbGl6ZUF1dGhTdGF0ZSA9ICgpID0+IHtcbiAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBzZWN1cmVTdG9yYWdlLmdldEF1dGhUb2tlbnMoKTtcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gc2VjdXJlU3RvcmFnZS5nZXRVc2VyRGF0YSgpO1xuICAgICAgXG4gICAgICBpZiAodG9rZW5zICYmIHVzZXJEYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgICAgICAgIHVzZXI6IHVzZXJEYXRhLFxuICAgICAgICAgIHRva2VuOiB0b2tlbnMudG9rZW4sXG4gICAgICAgICAgcmVmcmVzaFRva2VuOiB0b2tlbnMucmVmcmVzaFRva2VuLFxuICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGF1dGggc3RhdGUgZnJvbSBzZWN1cmUgc3RvcmFnZTonLCBlcnJvcik7XG4gICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCBjbGVhciBzdG9yYWdlIGFuZCBzdGFydCBmcmVzaFxuICAgICAgc2VjdXJlU3RvcmFnZS5jbGVhckF1dGhTdG9yYWdlKCk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gaW5pdGlhbFN0YXRlO1xufTtcblxuLy8gQ3JlYXRlIHNsaWNlXG5jb25zdCBhdXRoU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gIG5hbWU6ICdhdXRoJyxcbiAgaW5pdGlhbFN0YXRlOiBpbml0aWFsaXplQXV0aFN0YXRlKCksXG4gIHJlZHVjZXJzOiB7XG4gICAgcmVzZXRBdXRoU3RhdGU6IChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lcnJvciA9IG51bGw7XG4gICAgfSxcbiAgICBzZXRDcmVkZW50aWFsczogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLnVzZXIgPSBhY3Rpb24ucGF5bG9hZC51c2VyO1xuICAgICAgc3RhdGUudG9rZW4gPSBhY3Rpb24ucGF5bG9hZC50b2tlbjtcbiAgICAgIHN0YXRlLnJlZnJlc2hUb2tlbiA9IGFjdGlvbi5wYXlsb2FkLnJlZnJlc2hUb2tlbjtcbiAgICAgIHN0YXRlLmlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICBzdGF0ZS5tZmFSZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgc3RhdGUubWZhVG9rZW4gPSBudWxsO1xuICAgIH0sXG4gICAgY2xlYXJDcmVkZW50aWFsczogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS51c2VyID0gbnVsbDtcbiAgICAgIHN0YXRlLnRva2VuID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlZnJlc2hUb2tlbiA9IG51bGw7XG4gICAgICBzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm1mYVJlcXVpcmVkID0gZmFsc2U7XG4gICAgICBzdGF0ZS5tZmFUb2tlbiA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5jZWxNRkE6IChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUubWZhUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm1mYVRva2VuID0gbnVsbDtcbiAgICAgIHN0YXRlLmVycm9yID0gbnVsbDtcbiAgICB9LFxuICB9LFxuICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuICAgIGJ1aWxkZXJcbiAgICAgIC8vIExvZ2luXG4gICAgICAuYWRkQ2FzZShsb2dpbi5wZW5kaW5nLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSBudWxsO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGxvZ2luLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgc3RhdGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnVzZXIgPSBhY3Rpb24ucGF5bG9hZC51c2VyO1xuICAgICAgICBzdGF0ZS50b2tlbiA9IGFjdGlvbi5wYXlsb2FkLnRva2VuO1xuICAgICAgICBzdGF0ZS5yZWZyZXNoVG9rZW4gPSBhY3Rpb24ucGF5bG9hZC5yZWZyZXNoVG9rZW47XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UobG9naW4ucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5lcnJvciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgfSlcbiAgICAgIC8vIFJlZ2lzdGVyXG4gICAgICAuYWRkQ2FzZShyZWdpc3Rlci5wZW5kaW5nLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSBudWxsO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKHJlZ2lzdGVyLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgc3RhdGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnVzZXIgPSBhY3Rpb24ucGF5bG9hZC51c2VyO1xuICAgICAgICBzdGF0ZS50b2tlbiA9IGFjdGlvbi5wYXlsb2FkLnRva2VuO1xuICAgICAgICBzdGF0ZS5yZWZyZXNoVG9rZW4gPSBhY3Rpb24ucGF5bG9hZC5yZWZyZXNoVG9rZW47XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UocmVnaXN0ZXIucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5lcnJvciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgfSlcbiAgICAgIC8vIExvZ291dFxuICAgICAgLmFkZENhc2UobG9nb3V0LnBlbmRpbmcsIChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGxvZ291dC5mdWxmaWxsZWQsIChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnVzZXIgPSBudWxsO1xuICAgICAgICBzdGF0ZS50b2tlbiA9IG51bGw7XG4gICAgICAgIHN0YXRlLnJlZnJlc2hUb2tlbiA9IG51bGw7XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UobG9nb3V0LnJlamVjdGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICBzdGF0ZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgIH0pXG4gICAgICAvLyBSZWZyZXNoIHRva2VuXG4gICAgICAuYWRkQ2FzZShyZWZyZXNoQWNjZXNzVG9rZW4ucGVuZGluZywgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UocmVmcmVzaEFjY2Vzc1Rva2VuLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgc3RhdGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnRva2VuID0gYWN0aW9uLnBheWxvYWQudG9rZW47XG4gICAgICAgIHN0YXRlLnJlZnJlc2hUb2tlbiA9IGFjdGlvbi5wYXlsb2FkLnJlZnJlc2hUb2tlbjtcbiAgICAgIH0pXG4gICAgICAuYWRkQ2FzZShyZWZyZXNoQWNjZXNzVG9rZW4ucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5lcnJvciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBzdGF0ZS5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUudXNlciA9IG51bGw7XG4gICAgICAgIHN0YXRlLnRva2VuID0gbnVsbDtcbiAgICAgICAgc3RhdGUucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgICAgIH0pO1xuICB9LFxufSk7XG5cbi8vIEV4cG9ydCBhY3Rpb25zXG5leHBvcnQgY29uc3QgeyByZXNldEF1dGhTdGF0ZSwgc2V0Q3JlZGVudGlhbHMsIGNsZWFyQ3JlZGVudGlhbHMgfSA9IGF1dGhTbGljZS5hY3Rpb25zO1xuXG4vLyBFeHBvcnQgc2VsZWN0b3JzXG5leHBvcnQgY29uc3Qgc2VsZWN0Q3VycmVudFVzZXIgPSAoc3RhdGUpID0+IHtcbiAgLy8gRmlyc3QgdHJ5IHRvIGdldCBmcm9tIHN0YXRlXG4gIGlmIChzdGF0ZS5hdXRoLnVzZXIpIHtcbiAgICByZXR1cm4gc3RhdGUuYXV0aC51c2VyO1xuICB9XG4gIFxuICAvLyBJZiBub3QgaW4gc3RhdGUsIHRyeSB0byBnZXQgZnJvbSBzZWN1cmUgc3RvcmFnZVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VjdXJlU3RvcmFnZS5nZXRVc2VyRGF0YSgpO1xuICB9XG4gIFxuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RJc0F1dGhlbnRpY2F0ZWQgPSAoc3RhdGUpID0+IHtcbiAgLy8gRmlyc3QgY2hlY2sgc3RhdGVcbiAgaWYgKHN0YXRlLmF1dGguaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIC8vIElmIG5vdCBhdXRoZW50aWNhdGVkIGluIHN0YXRlLCBjaGVjayBzZWN1cmUgc3RvcmFnZVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gISFzZWN1cmVTdG9yYWdlLmdldEF1dGhUb2tlbnMoKTtcbiAgfVxuICBcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdEF1dGhUb2tlbiA9IChzdGF0ZSkgPT4ge1xuICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGZyb20gc3RhdGVcbiAgaWYgKHN0YXRlLmF1dGgudG9rZW4pIHtcbiAgICByZXR1cm4gc3RhdGUuYXV0aC50b2tlbjtcbiAgfVxuICBcbiAgLy8gSWYgbm90IGluIHN0YXRlLCB0cnkgdG8gZ2V0IGZyb20gc2VjdXJlIHN0b3JhZ2VcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgdG9rZW5zID0gc2VjdXJlU3RvcmFnZS5nZXRBdXRoVG9rZW5zKCk7XG4gICAgcmV0dXJuIHRva2Vucz8udG9rZW4gfHwgbnVsbDtcbiAgfVxuICBcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0QXV0aEVycm9yID0gKHN0YXRlKSA9PiBzdGF0ZS5hdXRoLmVycm9yO1xuZXhwb3J0IGNvbnN0IHNlbGVjdEF1dGhMb2FkaW5nID0gKHN0YXRlKSA9PiBzdGF0ZS5hdXRoLmlzTG9hZGluZztcblxuLy8gRXhwb3J0IHJlZHVjZXJcbmV4cG9ydCBkZWZhdWx0IGF1dGhTbGljZS5yZWR1Y2VyO1xuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiY3JlYXRlQXN5bmNUaHVuayIsImF1dGhTZXJ2aWNlIiwic2VjdXJlU3RvcmFnZSIsIlJPVVRFUyIsImluaXRpYWxTdGF0ZSIsInVzZXIiLCJ0b2tlbiIsInJlZnJlc2hUb2tlbiIsImlzQXV0aGVudGljYXRlZCIsImlzTG9hZGluZyIsImVycm9yIiwibWZhUmVxdWlyZWQiLCJtZmFUb2tlbiIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJyZWplY3RXaXRoVmFsdWUiLCJyZXNwb25zZSIsInJlcXVpcmVNRkEiLCJhZGRMb2dpblRvSGlzdG9yeSIsImlkIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwiZGV2aWNlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibG9jYXRpb24iLCJzdGF0dXMiLCJlbWFpbCIsInJlbWVtYmVyTWUiLCJzZXRBdXRoVG9rZW5zIiwic2V0VXNlckRhdGEiLCJkYXRhIiwibWVzc2FnZSIsInJlZ2lzdGVyIiwidXNlckRhdGEiLCJsb2dvdXQiLCJfIiwidG9rZW5zIiwiZ2V0QXV0aFRva2VucyIsImNsZWFyQXV0aFN0b3JhZ2UiLCJsb2dvdXRFcnJvciIsImNvbnNvbGUiLCJjYWNoZUtleXMiLCJPYmplY3QiLCJrZXlzIiwibG9jYWxTdG9yYWdlIiwiZmlsdGVyIiwia2V5Iiwic3RhcnRzV2l0aCIsImZvckVhY2giLCJyZW1vdmVJdGVtIiwid2luZG93IiwiY2FjaGVzIiwidGhlbiIsIm5hbWVzIiwibmFtZSIsImRlbGV0ZSIsImUiLCJ2ZXJpZnlNRkEiLCJjb2RlIiwiaXNCYWNrdXBDb2RlIiwidmVyaWZ5TUZBTG9naW4iLCJyZWZyZXNoQWNjZXNzVG9rZW4iLCJpbml0aWFsaXplQXV0aFN0YXRlIiwiZ2V0VXNlckRhdGEiLCJhdXRoU2xpY2UiLCJyZWR1Y2VycyIsInJlc2V0QXV0aFN0YXRlIiwic3RhdGUiLCJzZXRDcmVkZW50aWFscyIsImFjdGlvbiIsInBheWxvYWQiLCJjbGVhckNyZWRlbnRpYWxzIiwiY2FuY2VsTUZBIiwiZXh0cmFSZWR1Y2VycyIsImJ1aWxkZXIiLCJhZGRDYXNlIiwicGVuZGluZyIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwiYWN0aW9ucyIsInNlbGVjdEN1cnJlbnRVc2VyIiwiYXV0aCIsInNlbGVjdElzQXV0aGVudGljYXRlZCIsInNlbGVjdEF1dGhUb2tlbiIsInNlbGVjdEF1dGhFcnJvciIsInNlbGVjdEF1dGhMb2FkaW5nIiwicmVkdWNlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/store/slices/authSlice.js\n"));

/***/ })

});